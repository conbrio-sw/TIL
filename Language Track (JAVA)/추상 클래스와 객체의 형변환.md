## 21.12.30

# 추상 클래스와 내부 클래스
### abstract 예약어
- 추상 매서드
  + abstract 예약어 : 매서드와 클래스를 선언할 때 사용하는 Modifier
  + 매서드를 선언할 때 abstract 예약어를 붙이면 현재 매서드를 추상 매서드로 정의하겠다는 의미
  + 매서드의 시그니쳐(리턴타입, 매서드명, 매개변수)만 정의
  + 구체적인 행위, 즉 블록{} 부분은 정의되지 않은 특수한 매서드
  ```java
  abstract void printName();
  ```
  + 매서드의 시그니쳐가 선언되어 있기 때문에 매서드의 기본적인 기능 유추 가능
  + 의미가 없는 추상 매서드 ---"자식 클래스에서 Overriding"---> 상속을 통해 의미를 가지는 추상 매서드
    + 추상 매서드는 상속과 관련이 깊은 예약어임
- 추상 클래스
  + 클래스 선언부에 abstract를 선언하면 해당 클래스를 추상 클래스로 선언한다는 의미가 됨
  ```java
  abstract class AbstractClass{
    public void methodA(){}
    public abstract void methodB();
  ```
  + 추상 클래스는 일반적으로 하나 이상의 추상 매서드를 포함함 (추상 매서드가 없는 클래스도 추상 클래스로 선언 가능)
  + 추상 매서드를 포함하고 있는 클래스는 추상 클래스로 선언되어야함
  + 추상 클래스는 객체 생성을 할 수 없음 (문법적으로 객체생성을 허용하지 않음)
  + 자바가 추상 클래스를 지원하는 이유는 상속과 결합해서 생각해야함
  + 자식 클래스가 추상 클래스를 부모로 하여 상속을 받으면 추상 클래스에 있는 추상 매소드를 구현해야한다
  + 추상 매서드를 Overriding 하지 않으면 자식 클래스도 추상 클래스로 정의되어야 한다
  + 자식 클래스는 부모의 모든 추상 매서드를 overriding 해야 객체를 생성할 수 있다.
- 추상 클래스의 활용
  + 추상 클래스로 객체를 생성하려면 자식 클래스를 작성하고 추상 매서드들을 Overriding 해야함
  + 추상 클래스를 사용해야 유지보수의 편의성을 높일 수 있음
  + 모든 클래스의 매서드 시그니쳐를 통일할 수 없음
  + 다른 TV 클래스에 어떤 매서드가 정의되어 있는지 일일이 확인할 수 없음
  + 추상 클래스를 적용하면, 모든 TV클래스들의 매서드를 통일할 수 있음
- 추상 클래스를 이용하여 TV 클래스들을 구현 ===>>> TV를 상속한 모든 TV클래스들에 동일한 매서드들이 포함됨
- 최소한의 수정으로 원하는 객체를 사용할 수 있게 되어 유지보수성이 좋아짐
### 내부 클래스
- 내부 클래스들의 특징
  + 클래스가 다른 클래스를 포함하는 경우, 내부에 포함된 클래스를 내부 클래스라고 함
    * JDK 초기 버전부터 지원되었던 개념
    * 파일 크기의 최소화, 보안, 성능향상, 이벤트 처리 등을 쉽게하기 위하여 사용됨
  + 내부 클래스는 정의되는 위치에 따라서 멤버 클래스와 지역 클래스로 나뉨
  + 멤버 클래스
    * 멤버 변수와 동일한 위치에 선언된 내부 클래스
    * instance 멤버와 static 예약어가 붙은 static 멤버로 나뉨
    * 동일한 클래스 뿐만 아니라 다른 클래스에서도 활용될 수 있음
    * 클래스의 멤버 변수와 성격이 비슷함   
  + 지역 클래스
    * 매서드 내에 클래스가 정의되어 있는 경우
    * 지역클래스(이름有)와 무명클래스(이름無)로 나뉨
    * 활용 범위가 매서드 블록 내부로 제한되는 특징을 갖는 등 지역 변수와 성격이 비슷함
  + 자바의 클래스 구조를 더 조직화, 소스코드를 구현 시 효율을 높일 수 있음
  + 내부 클래스가 생성되기 위해서는 외부 클래스의 객체가 반드시 필요함
- instance 멤버 내부 클래스
  + instance 멤버 내부 클래스는 클래스의 멤버와 동일한 위치에서 선언되는 내부 클래스
  + 멤버 변수나 매서드와 동일한 위치에서 선언되었기 때문에 다른 외부의 클래스에서도 사용 가능함
  + Outside outer = new Outside();  |  Ouside.Inside inner = outer.new Inside(); => 외부 클래스 Outside, 내부 클래스 Inside 일시 사용법
  + Outside.class | Oustside$Inside.class => 외부클래스명$내부클래스명.class
- static 멤버 내부 클래스
  + 내부 클래스를 정의할 때도 static 예약어를 사용할 수 있음
  + 외부 클래스의 객체를 생성하지 않고도 내부 클래스 객체 생성할 수 있음
  + Outside.StaticInner sinner = new Outside.StaticInner();
- 이름이 있는 지역 내부 클래스
  + 매서드 내부에서 정의된 클래스로서 지역 변수와 동일한 범위를 가짐
  + 클래스의 이름이 명시되는 클래스임
  + Animal.class  | Animal$1$Brain.class  =>  외부클래스명$1$지역내부클래스명.class
- 이름이 없는 지역 내부 클래스
  + 이름을 갖지 않는 내부 클래스임
  + new 예약어 뒤에 명시된 클래스가 기존의 클래스인 경우에는 자동적으로 이 클래스의 자식 클래스가 됨
  + 이름이 없기 때문에 무명의 내부 클래스라고도 함
  + 이름이 없는 지역 내부 클래스는 추상 클래스의 객체를 내부 클래스 형태로 생성할 때 자주 사요됨
  + 추상 클래스는 추상 매서드를 포함하고 있기 때문에 객체를 생성할 수 없음
    * 추상 클래스를 상속한 클래스가 만들어져 객체를 생성해야 함
    * 간단하게 이름이 없는 지역 내부 클래스로 만들어 사용하는 것이 편리할 수 있음
# 객체의 형변환
### 형변환 개요
- 형변환의 개념
  + 묵시적 형변환 : 작은 데이터 타입 => 큰 데이터 타입 : 데이터 손실의 우려가 없어 자동 캐스팅
  + => 형변환 연산자를 사용하지 않아도 자동으로 이루어지는 경우 | double avgAge = age; | age는 int형
  + 명시적 형변환 : 큰 데이터 타입 => 작은 데이터 타입 : 데이터 손실의 우려로 명시적 캐스팅
  + => 축소형변환 | int age = (int)avgAvg;  | 문장에서 명시적 형변환이 발생
- 객체 형변환의 개요
  + 객체 참조 변수의 경우에도 형변환(Casting)이 이루어짐
  + 부모클래스 = 자식클래스
  + 왼쪽 항과 오른쪽 항의 객체 유형이 서로 다른 경우 두 유형이 서로 상속 관계에 있음
  + 왼쪽 객체가 오른쪽 객체의 상위 클래스인 경우에만 묵시적 형변환이 나타남
  + 자식 클래스에서 부모 클래스 유형으로 할당하는 것은 가능하지만, 반대의 경우 명시적 형변환을 해야함
  + 부모 클래스 유형을 자식 클래스 유형으로 강제 형변환하는 경우에는 할당되는 인스턴스 유형에 따라서 실행 오류 발생
  + 내부 특정 클래스 형이 다른 클래스 형으로 변환될 수 있는지 여부를 수시로 판단해야함
  + instanceof 연산자를 사용함
    * 생성된 객체가 class와 관계있는 형(type)으로 만들어져있는지 확인
    * true 또는 false 값을 반환
    * m instanceof b 형태로 사용 (자식객체 instanceof 부모클라스 = true)
- 객체의 형변환
  + 클래스의 형변환은 기본적으로 상속관계가 아닌 클래스 사이에는 발생하지 않음
  + 자식 클래스의 객체는 부모 타입의 참조 변수에 할당될 수 있음(묵시적 형변환)
  + Employee 객체에 접근할 수 있는경우 
    * Employee e1 = new Employee();
    * e1 참조 변수는 타입이 Employee이고 Employee 객체를 참조함
    * 타입과 생성된 객체가 모두 Employee임
    * Employee 객체가 가지고 있는 변수나 매서드 모두 접근이 가능함
  + Employee, Manager 객체에 모두 접근할 수 있는 묵시적 형변환인 경우
    * Manger m1 = new Manager();
    * m1 참조 변수는 타입이 Manager이고, Manager 객체를 참조함
    * 타입과 생성된 객체가 모두 Manager임
    * Mangager 객체의 맴버 필드와 매서드 모두 접근이 가능함
    * Employee 클래스로부터 상속받았으므로, 객체 생성시 Manager 객체뿐만 아니라 Employee 객체도 생성
    * Manager 객체 생성 시 Emplayee가 가진 속성이 메모리상에 로딩됨
    * m1 참조변수를 통해 Employee, Manager 객체의 변수와 매서드를 모두 접근할 수 있음
  + 생성된 객체와 참조하는 변수의 타입이 다른 경우
    * Employee e2 = new Manager();
    * e2 참조 변수는 타입이 Employee이고, Manager 객체를 참조함
    * Manager는 Employee를 상속하기 때문에 Employee 객첵가 가진 변수와 매서드 모두를 가지고 있는 객체임
    * 생성된 객체는 Manager이지만 참조 변수의 타입이 Employee이므로, 접근 가능한 변수와 매서드는 같이 Employee 객체로 제한됨
  + Employee, Manager 객체에 모두 접근할 수 있는 명시적 형변환인 경우
    * Manager m2 = (Manager)e2;
    * m2참조 변수는 타입이 Manager이고, Manager 객체를 참조함
    * Employee 형의 e2 참조 변수를 Manager 형으로 명시적 형변환을 하고 있음
    * m2는 Manager 타입이므로 e2가 참조하고 있던 Manager 객체의 모든 멤버 필드와 매서드에 접근이 가능함
- 객체의 형변환 적용
  + 객체의 형변환을 이용하면 프로그램을 좀 더 유지보수가 편한 구조로 변경할 수 있음
  + 이게 안되면 TV 객체가 변경될 때 마다 객체 생성 코드를 수정해야만 함
  + 객체의 형변환을 이용하면 소스 수정 없이 TV객체를 바꿔서 실행할 수 있음
- 형변환과 멤버 변수
  + 형변환에 참여한 서로 상속 관계에 있는 두 클래스 간에는 동일한 이름의 변수가 존재하거나 매서드가 Overriding 되어 있을 수 있음
  + 생성된 객체 변수를 통해 멤버에 접근할 때 주의해야함
- 객체 참조 변수가 변수나 매서드를 참조하는 경우, 참조 관계를 결정하는 시간이 다르기 때문에 차이가 난다.
  + 변수에 대한 접근은 객체의 유형에 의해 결정됨
  + 매서드 호출은 할당되는 인스턴스에 의해 결정됨












