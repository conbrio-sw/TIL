## 캐시 기본 동작

- 캐시가 없을 때

  - 요청
  - 전송 (1.1MB)
  - 똑같은 요청
  - 똑같은 전송 (1.1MB)

  ----------------

  - 데이터가 변경되지 않아도 계속 너트워크를 통해서 데이터를 다운로드 받아야한다.

  - 인터넷 네트워크는 매우 느리고 비싸다
  - 브라우저 로딩 속도가 느리다
  - 느린 사용자 경험

- 캐시 적용

  - 캐시가 유효한 시간을 포함한 응답 전송

  - 응답 결과를 캐시에 저장 (브라우저 캐시에)

  - 같은 요청 브라우저 캐시에서 해결

    -----------

  - 캐시 덕분에 캐시 가능 시간 동안 네트워크 사용 X

  - 비싼 네트워크 사용량을 줄일 ㅅ ㅜ있다.

  - 브라우저 로딩 속도가 매우 느리다.

  - 빠른 사용자 경험

- 캐시 적용(캐시 시간 초과)
  - 캐시 유효 시간 검증
  - 캐시 유효한 시간 포함한 똑같은 응답
- 캐시 시간 초과
  - 캐시 유효 시간이 초과하면, 서버를 통해 데이터를 다시 조회하고 캐시 갱신
  - 이때 다시 네트워크 다운로드 발생

## 검증 헤더와 조건부 요청 1

- 캐시 유효 시간이 초과해서 서버에 다시 요청하면 다음 2가지 상황
  - 서버에서 기존 데이터 변경
  - 서버에서 기존 데이터 변경 X
- 캐시 만료 후에도 서버에서 데이터 변경하지 않음
- 생각해보면 데이터를 전송하는 대신에 저장해 두었던 캐시를 재사용
- 단 클라이언트의 데이터와 서버의 데이터가 같다는 사실을 확인할 수 있는 방법이 필요

- 해결책이 검증 헤더
  - `Last-Modified ` 최종 수정일 추가
  - 캐시 검증 시간을 초과한 요청 (조건부 요청) `if-modified-since`
    - 최종 수정일을 추가해서 요청메시지 보냄
    - 서버에서 날짜보고 판단
    - 옛날 캐시 그대로 사용 가능
      - `304 Not Modified` 헤더 보냄
        - HTTP Body가 없음 (수정한 게 없기 때문에)
        - 0.1MB 전송 (HTTP Body 전송을 안하기 때문에)
- 정리
  - 캐시 유효시간이 초과해도 서버의 데이터가 갱신되지 않으면 304 Not Modified + 헤더 메타 정보만 응답
  - 클라이언트는 서버가 보낸 응답 헤더 정보로 캐시의 메타 정보를 갱신
  - 클라이언트는 캐시에 저장되어 있는 데이터 재활용
  - 결과적으로 네트워크 다운로드가 발생하지만 용량이 적은 헤더 정보만 다운로드
  - 매우 실용적인 해결책

## 검증 헤더와 조건부 요청 2

- 검증 헤더

  - 캐시 데이터와 서버 데이터가 같은지 검증하는 데이터
  - Last-Modified, ETag

- 조건부 요청 헤더

  - 검증 헤더로 조건에 따른 분기
  - If-Modified-Since: Last-Modified 사용
  - if-None-Match : ETage 사용
  - 조건 만족하면 200 OK
  - 조건 만족하지 않으면 304 Not Modified

- If-Modified-Since : 이후에 데이터 수정되었으면?

  - 데이터ㅁ 미변경 예시
    - 캐시와 서버 똑같은 최종 수정일
    - 304 Not Modified, 헤더 데이터만 전송 (바디 미포함)

  - 데이터 변경 예시
    - 다른 최종 수정일
    - 200 Ok, 모든 데이터 전송(바디 포함)
  - 단점
    - 1초 미만 단위로 캐시 조정일 불가능
    - 날짜 기반의 로직 사용
    - 데이터를 수정해서 날짜가 다르지만, 같은 데이터를 수정해서 데이터 결과가 똑같은 경우
    - 서버에서 별도의 캐시 로직을 관리하고 싶은 경우
      - 스페이스나 주석처럼 크게 영향이 없는 변경에서 캐시를 유지하고 싶은 경우

- ETag, If-Nono-Match
  - ETag(Entity Tag)
  - 캐시용 데이터에 임의의 고유한 버전 이름을 달아둠
    - 조금이라도 컨텐츠가 다르면 해시 라이브러리에 의해 해시 값이 변경됨
  - 데이터가 변경되면 이 이름을 바꾸어서 변경함(Hash를 다시 생성)
  - 진짜 단순하게 ETag만 보내서 같으면 유지, 다르면 다시 받기
  - 응답으로 ETag를 포함한 것을 보냄
  - 캐시 유효 시간이 초과되면 요청으로 캐시에 있는 ETag 값을 보내서 비교
  - 나머진 똑같음
- 정리
  - ETag만 서버에 보내서 같으면 유지, 다르면 다시 받기
  - 캐시 제어 로직을 서버에서 완전히 관리
  - 클라이언트는 단순히 이 값을 서버에 제공(클라이언트는 캐시매커니즘을 모름)

## 캐시와 조건부 요청 헤더

- 캐시 제어 헤더
  - 캐시 컨트롤
  - 프라그마
  - 익스파이어스,

- Cache-Control
  - 캐시 지시어
  - Cahche-Control: max-age
    - 캐시 유효 시간, 초 단위
  - Cahche-Control: no-cache
    - 데이터는 캐시해도 되지만 항상 원(origin) 서버에 검증하고 사용
    - 중간 서버에서 뭘 하면 안된다
  - Cahche-Control: no-store
    - 데이터에 민감한 정보가 있으므로 저장하면 안됨 (메모리에서 사용하고 최대한 빨리 삭제)

## 프록시 캐시

- 원서버 직접 접근 (미국에 있는)
  - 500ms 걸린다고 가정
- 프록시 캐시 서버 도입 (한국에 어딘가에)
  - 100ms 걸림
  - 유튜브 외국 인기 없는 거보면 느리지만 인기 있는거 보면 빠른 이유
  - 공용으로 사용하는 캐시 서버 (public 캐시)
    - 로컬이나 개인이 사용하는 건 private 캐시
- 캐시 컨트롤
  - 캐시 지시어(directives) - 기타
  - Cache-Control: public
    - 응답이 public 캐시에 저장되어도 됨
  - Cache-Control: private
    - 응답이 해당 사용자만을 위한 것임, private 캐시에 저장해야 함(기본값)
  - Cache-Control: s-maxage
    - 프록시 캐시에만 적용되는 max-age
  - Age: 60 (HTTP 헤더)
    - 오리진 서버에서 응답 후 프록시 캐시 내에 머문 시간 (초)



## 캐시 무효화

- 캐시 컨트롤

  - 확실한 캐시 무효화 응답
  - Cache-Control: no-cache, no-store, must-revalidate
  - Pragma: no-cache
    - HTTP 1.0 하위 호환 

- 캐시 지시어 - 확실한 캐시 무효화

  - Cache-Control : no-cahce
    - 데이터는 캐시해도 되지만, 항상 원 서버에 검증하고 사용(이름에 주의)

  - Cache-Control: no-stroe
    - 데이터에 민감한 정보가 있으므로 저장하면 안됨 (메모리에서 사용하고 최대한 빨리 삭제)
  - Cache-Control: must-revalidate
    - 캐시 만료 후 최초 조회 시 원 서버에 검증해야함
    - 원 서버 접근 실패 시 반드시 오류가 발생해야함 - 504(Gateway Timeout)
    - must-revalidate는 캐시 유효 시간이라면 캐시를 사용함
  - Pragma: no-cahce

- no cache, must revalidate 차이

  - no-cache
    - 원 서버에 접근할 수 없는 경우 캐시 서버 설정에 따라서 캐시 데이터를 반환할 수 있음
    - Error or 200OK (오류보다는 오래된 데이터라도 보여주자...라고 설정되있을 경우)
  - must-revalidate
    - 원 서버에 접근할 수 없는 경우 항상 오류가 발생해야함
    - 504 Gateway Timeout (매우 중요한 돈과 관련된 결과로 생각해보자)



























