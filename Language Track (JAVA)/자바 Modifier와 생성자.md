## 21.12.30

# 자바의 Modifier
### static 예약어
- 클래스 변수
  + static 예약어 : 멤버 변수와 메서드 앞에 붙일 수 있는 modifier로서, 활용 방법을 제어함
  + static 예약어가 붙지 않는 __인스턴스 변수__
    * 생성된 인스턴스마다 그 안에 클래스의 인스턴스 변수들이 포함됨
    * 일반적인 멤버 변수를 인스턴스 변수라고 부름
    * 클래스로부터 객체가 생성될 때 마다 각 객체의 변수들이 생성됨
    * 한 객체의 값이 변경되어도, 다른 객체의 값에 영향을 주지 않음
  + static 예약어가 붙는 __클래스 변수__
    * 클래스로부터 생성된 인스턴스에 포함되지 않는 변수
    * 많은 인스턴스를 생성하더라도 메모리에 하나의 변수만 존재함
    * 객체를 생성하지 않고도 접근할 수 있는 변수
    * 클래스로부터 생성된 모든 객체들이 하나의 클래스 변수를 공유함
    * 객체가 생성될 때 메모리 영역을 할당하지 않고, __클래스가 로딩되는 과정에서 메모리에 한번만 할당되는 멤버__
      - 클래스 변수의 값이 변경되는 경우, 클래스로부터 생성된 모든 객체에서 변경된 값을 사용 가능함
  + 클래스 변수가 필요한 이유 
    * 동일한 값을 가지고 있는 변수를 인스턴스 변수로 선언하면 각 객체에 동일한 인스턴스 변수가 포함됨 : 메모리 관리에 악영향  
- 클래스 변수의 접근
  * 클래스 변수는 일반적으로 객체 참조 변수 이름으로 접근하기보다는 클래스 이름을 통해서 접근함
  * 객체를 생성하지 않고도 클래스 변수에 접근 가능함
  * 지금까지 사용했던 자바 출력문은 모두 system 클래스의 out이라는 클래스 변수를 이용한 것
- 클래스 메서드
  + 매서드에서도 static 예약어를 사용가능함
  + 인스턴스를 생성하지 않고도 사용가능함
  + Integer 클래스의 parseInt() 메서드가 대표적인 클래스 메서드임
  + 클래스 메서드는 클래스 변수와 클래스 메서드만 접근가능
### final 예약어
- 변수와 final
  * final 예약어를 사용하여 변수를 선언하면 할당된 값을 변화시킬 수 없음
  * final이 붙은 변수는 단 한 번 초기화가 가능하지만, 초기화 이후에는 값을 변경할 수 없는 상수임 (선언과 초기화가 클래스 영역 내에서 반드시 끝내야함)
  * 클래스 변수(static 변수)는 모든 객체들이 동일한 값을 가지므로 이것을 final 예약어와 결합하여 초기화한 동일한 값을 변경할 수 없게 하는 것이 일반적
  ```java
  final static String COMPANY_NAME = "s전자"'
  ```
  * 상수의 이름은 일반 인스턴스 변수와 구분하기 위해서 모두 대문자로 선언함
  * 여러 단어가 결합된 경우라면 단어와 단어 사이에 '_'를 이용하여 선언
- 메서드와 final
  * 메서드 앞에 final이 붙으면 부모 클래스를 상속받은 자식 클래스에서 메서드 재정의(overriding)을 금지함
    + 매서드 재정의(overridng)은 상속 구조에서 부모의 메서드와 동일한 모양의 메서드를 새롭게 정의하는 것을 말함
    ```java
    class car{
      public final void print(){statement1;}
    }
    class taxi extends car{
      public void print(){statement2;}    // 오류발생
    }
    ```
- 클래스와 final
  * 클래스를 선언할 때 클래스 앞에 final 예약어를 추가하면 상속 금지를 의미함
### abstract 예약어
- 추상 메서드
  * abstract 예약어는 클래스와 메서드를 선언할 때 사용하는 modifier임
  * 클래스 선언부에서 사용시 : 추상 클래스로 선언함
  * 메서드를 선언할 때 사용시 : 추상 메서드를 정의함
  * 메서드의 시그니쳐(리턴 타입, 메서드명, 매개변수)만 정의되고 구체적인 행위, 즉 블록{} 부분은 정의되지 않는 메서드를 의미함
  ```java
  returnType name(argName, argInt ....){...}
  abstract returnType name(argName, argInt ...);
  abstract int sum(int num1, int num2);
  ```
  * 추상 메서드를 선언할 때 abstract 예약어는 메서드 앞에 붙여야 함
  * 블록 부분은 생략함
  * 메서드 시그니쳐가 선언되어 있어서, 메서드의 기본적인 기능은 유추가능함
- 추상 클래스
  * 추상 메서드를 포함하고 있는 클래스는 추상 클래스로 선언되어야 함
  * 추상 클래스가 추상 메서드를 포함하지 않을 수도 있음
  ```java
  abstract class AbstractClass{
    public abstract void methodA();
    public void methodB(){}
  }
  ```
  * 추상클래스와 상속이 결합되어야 정확하게 추상 클래스를 이해할 수 있음
  * 상속은 부모 클래스의 모든 변수와 메서드가 자식 클래스로 상속되어 들어오는 개념
  * 추상클래스를 부모로 상속받는 자식 클래스는 추상클래스로 선언하거나 부모클래스의 추상 메서드를 재정의(overriding) 해야한다.
# 생성자
### 생성자 개요
- 생성자의 개념
  + 생성자(Constructor)는 클래스로부터 객체를 생성할 때 호출되며, 객체의 멤버 변수를 초기화하는데 사용되는 메서드임
  + 객체를 생성할 때 객체에 필요한 값들을 초기화하는 개념은 배열과 동일함
  + 객체 생성 및 생성된 객체에 필요한 데이터를 초기화하는 과정을 단순화하여 코드의 양을 줄이는 역할 수행
- 생성자의 특징
  * 생성자는 클래스와 같은 이름을 가진 특별한 메서드로서 객체 생성 시 멤버 변수의 초기화를 담당함
  * 일반 멤버 메서드와 달리 반환형 (return type)이 없음  | void도 허용되지 않음
  * 생성자는 이름은 같지만 매개변수를 달리하여 여러 개를 중복정의 (overloading)할 수 있음
  * 생성자는 키워드 new와 항상 같이 사용됨 | car a = new car();
  * 명시적으로 작성하지 않을 경우, 기본 생성자가 제공됨
  * [access modifier] class명 ([argument list])){...}
  * public : 모든 클래스에서 접근 가능
  * protected : 동일 패키지에 속하는 클래스와 하위 클래스 관계의 클래스에 의해 접근 가능
  * private : 클래스 내에서만 접근 가능
- 기본 생성자 (default constructor)
  * 클래스에 생성자가 하나도 정의되지 않은 경우 컴파일러에 의해 자동으로 생성되는 생성자 | 하나라도 정의되어 있으면 자동 제공 X
  * default로 생성되면 초기값은 0, null, false
- 이클립스에서 [alt] + [shift] + [s] 같이 눌러서 자동생성 가능
### this의 의미와 사용법
- this의 의미
  * 생성자나 매서드의 매개변수 이름이 객체 변수의 이름과 같다면, 객체 변수 이름 앞에 this를 사용해서 구별함
  * 매개변수 이름을 매번 다른 이름으로 만들기 어렵고 가독성이 떨어지고 어떤 값이 넘어오는지 알 수 없기 때문에 this 예약어를 사용








